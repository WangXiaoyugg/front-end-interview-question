### 如何解决移动端 1px 问题 ？
答题思路：先解释什么 1px问题，然后在阐述常见的解决方案

#### 参考答案：
1px问题指的是: 在retina的高分辨屏幕的机型上，移动端页面的
1px会变得很粗。

原因：CSS 中 1px 不等同于移动设备上的1px, 它们之间的比例关系用 `window.devicePixelRatio = 设备的物理像素 / CSS像素` 属性表示。例如：iphone6 的 `devicePixelRatio`的值为2， 表示 1px CSS像素会用2个物理像素渲染，所以实际看到一定比1px粗

方案1： 直接写 0.5px, 缺陷是兼容性不行，IOS系统需要8以上，安卓系统不兼容

```jsx
// 以 JSX 为例
<div id="app" data-device={{window.device}}></div>
```
```css
#app[data-device="2"] {
    border: 0.5px solid #ddd;
}
```

方案2： 伪元素先放大再缩小，兼容性更好，缺点是代码会变多

```css
#app {
    position: relative;
}
#app:after {
    content: '';
    display: block;
    position: absolute;
    top: 0;
    left: 0;
    width: 200%;
    height: 200%;
    border: 1px solid #333;
    transform-origin: left top;
    transform: scale(0.5);
    box-sizing: border-box;
}
```

### html中元素的层叠顺序
层叠顺序（stacking order）,表示元素发生层叠时有着特定的垂直显示顺序，下面盒模型的层叠规则，从下到上分别是：
1. 背景和边框
2. z-index < 0
3. 块级盒子
4. 浮动盒子
5. 行内盒子
6. z-index = 0
7. z-index > 0
注意：当定位元素为z-index：auto, 生成盒在当前层叠上下文中的层级为0，不会建立新的层叠上下文，除非是根元素

## 常见的CSS布局单位
常见的布局单位有：px, %, em, rem, vw/vh
1. px, 1px 表示屏幕上所能显示的最小区域，像素分为CSS像素和物理像素， CSS像素是一个抽象单位，物理像素与设备的硬件密度相关
2. %， 百分比当浏览器的宽高发生变化时，通过百分比可以使浏览器中元素宽高随之变化，实现响应式效果，一般认为子元素的百分比直接相对于父元素
3. em, rem 都是相对长度单位，em 相对于父元素，rem相对于根元素。em 文本相对长度，如果当前行内文本的字体未被认为设置， 相对于浏览器的默认字体大小（16px）, 利用rem可以简单实现响应式布局，通过元素的字体大小和屏幕之间的比值来设置font-size的值来实现
4. vw/vh 是视口有关的单位，vw表示相对于试图窗口的宽度，
   vh表示相对于视图窗口的高度，除了vw和vh外，还有vmin和vmax, vmin: vw和wh的较小值，vmax: vw和vh中的较大


### CSS水平垂直居中的实现
1. 方案1, 定位 + transform
```css
.parent {
    position: relative;
}
.child {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
}
```
2. 方案2， 定位 + margin (auto)， 适用于宽高已知
```css
.parent {
    position: relative;
}
.child {
    position: absolute;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    margin: auto;
}
```
3. 方案3， 定位 + margin(负值)， 适用于宽高已知 
```css
.parent {
    position: relative;
}
.child {
    position: absolute;
    top: 50%;
    left: 50%;
    margin-left: -50px;
    margin-top: -50px;
}
```
4. 方案4， flex 布局
```css
.parent {
    display: flex;
    align-items: center;
    justify-content: center;
}
```
5. 方案5， grid 布局
```css
.parent {
    display: grid;
    align-content: center;
    justify-content: center;
}
```
```css
.parent {
    display: grid;
}
.child {
    align-self: center;
    justify-self: center;
}
```
6. 方案6， table-cell
```css
.parent {
    display: table-cell;
    text-align: center;
    vertical-align: middle;
}
.child {
    display: inline-block;
}
```

